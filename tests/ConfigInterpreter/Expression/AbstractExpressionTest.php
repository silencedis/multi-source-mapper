<?php

namespace SilenceDis\MultiSourceMapper\Test\ConfigInterpreter\Expression;

use PHPUnit\Framework\TestCase;
use SilenceDis\MultiSourceMapper\ConfigInterpreter\Expression\AbstractExpression;
use SilenceDis\PHPUnitMockHelper\MockHelper;
use SilenceDis\ProtectedMembersAccessor\ProtectedMembersAccessor;

/**
 * Class AbstractExpressionTest
 *
 * @author Yurii Slobodeniuk <silencedis@gmail.com>
 *
 * @coversDefaultClass \SilenceDis\MultiSourceMapper\ConfigInterpreter\Expression\AbstractExpression
 */
class AbstractExpressionTest extends TestCase
{
    /**
     * @return \PHPUnit_Framework_MockObject_MockObject|AbstractExpression
     * @throws \SilenceDis\PHPUnitMockHelper\Exception\InvalidMockTypeException
     */
    private function mockExpression()
    {
        return (new MockHelper($this))->mockObject(
            AbstractExpression::class,
            [
                'mockType' => MockHelper::MOCK_TYPE_ABSTRACT,
            ]
        );
    }
    
    /**
     * @covers ::getKey
     *
     * @throws \SilenceDis\PHPUnitMockHelper\Exception\InvalidMockTypeException
     * @throws \SilenceDis\ProtectedMembersAccessor\Exception\ProtectedMembersAccessException
     */
    public function testGetKey_firstCall()
    {
        $expression = $this->mockExpression();
        
        // Set the value `null` for the `key` property forcibly to ensure it's emptiness.
        (new ProtectedMembersAccessor())->setProtectedProperty(AbstractExpression::class, $expression, 'key', null);
        
        $actualResult = $expression->getKey();
        $this->assertTrue(
            is_string($actualResult),
            "The generated key value must be a string and it must be generated by the `uniqid` function."
        );
    }
    
    /**
     * @covers ::getKey()
     *
     * @throws \SilenceDis\PHPUnitMockHelper\Exception\InvalidMockTypeException
     * @throws \SilenceDis\ProtectedMembersAccessor\Exception\ProtectedMembersAccessException
     */
    public function testGetKey_whenAlreadySet()
    {
        $testKeyValue = 'foo';
        
        $expression = $this->mockExpression();
        
        // Set value of the `key` property to check that it wil be returned when next calling of the `getKey()` method.
        (new ProtectedMembersAccessor())->setProtectedProperty(
            AbstractExpression::class,
            $expression,
            'key',
            $testKeyValue
        );
        
        $actualResult = $expression->getKey();
        $this->assertEquals($testKeyValue, $actualResult, "If the key is already set, it's value must be returned.");
    }
}
